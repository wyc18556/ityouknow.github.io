---
layout: post
title: 数据结构与算法之美-跳表
category: note
no-post-nav: true
---

对有序链表稍加改造，就可以支持类似“二分”的查找算法，我们把改造之后的数据结构叫做跳表。

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

## 什么是跳表
我们知道，对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是O(n)。我们可以通过在链表上建立多级索引的方式提高查询效率，这就是跳表结构，如下图所示：
![跳表结构](http://image.wyc1856.club/2019-12-13-10-51-42.png)

## 复杂度
从上图中可看出，跳表索引层级越多，时间复杂度越低但空间复杂度就越高，那么时间复杂度和空间复杂度到底是多少呢？

### 时间复杂度
如果链表有n个节点，我们按每两个节点抽出一个节点作为上一级索引的节点，那第一级索引的结点个数大约就是n/2，第二级索引的结点个数大约就是n/4，第三级索引的结点个数大约就是n/8，依次类推，也就是说，第k级索引的结点个数是第k-1级索引的结点个数的1/2，那第k级索引结点的个数就是(n/\\(2^k)\\)。    

假设索引有h级，最高级的索引有2个结点。通过上面的公式，我们可以得到(n/\\(2^k)\\)=2，从而求得h = (\\(log_{2}^n)-1\\)，如果包含原始链表这一层，整个跳表的高度就是 (\\(log_{2}^n)\\)。我们在跳表中查询某个数据的时候，如果每一层都要遍历m个结点，那在跳表中查询一个数据的时间复杂度就是 O(\\(m*log^n)\\)。    

假设我们要查找的数据是x，在第k级索引中，我们遍历到y结点之后，发现x大于y，小于后面的结点z，所以我们通过y的down指针，从第k级索引下降到第k-1级索引。在第k-1级索引中，y和z之间只有3个结点(包含y和z)，所以，我们在K-1级索引中最多只需要遍历3个结点，依次类推，每一级索引都最多只需要遍历3个结点。
![跳表查询](http://image.wyc1856.club/2019-12-13-11-16-02.png)
通过上面的分析，我们得到m=3，所以在跳表中查询任意数据的时间复杂度就是O(\\(log^n)\\)。这个查找的时间复杂度跟二分查找是一样的。

### 空间复杂度
假设原始链表大小为n，那第一级索引大约有n/2个结点，第二级索引大约有n/4个结点，以此类推，每上升一级就 减少一半，直到剩下2个结点。如果我们把每层索引的结点数写出来，就是一个等比数列。
![等比数列](http://image.wyc1856.club/2019-12-13-11-21-03.png)
根据等比数列求和公式求得：n/2+n/4+n/8...+8+4+2=n-2。所以跳表的空间复杂度是O(n)。

## 插入和删除
插入节点时，需要先找到要插入的位置，这个操作的时间复杂度和查找一个元素的时间复杂度一样，都是O(\\(log^n)\\)。删除操作也是如此，首先要找到待删除元素，然后进行删除操作。需要注意一点，如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要删除索引中的。

## 跳表索引动态更新
当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某2个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。
![跳表退化](http://image.wyc1856.club/2019-12-13-11-32-05.png)
作为一种动态数据结构，我们需要某种手段来索引与原始链表大小之间的平衡，如果链表中的节点多了，索引节点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。    

当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值K，那我们就将这个结点添加到第一级到第K级这K级索引中。

随机函数的选择很有讲究，从概率上来讲，可以设置50%的概率返回1、25%的概率返回2、12.5%的概率返回3，后序依次类推，返回k的概率为(\\(1/2^k)\\)。

可以[点击这里](https://github.com/wyc18556/algorithms/blob/master/src/other/SkipList.java)查看跳表的代码实现。