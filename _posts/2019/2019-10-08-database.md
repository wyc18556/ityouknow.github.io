---
layout: post
title: 数据库笔记
category: database
tags: [MySql, Redis, mongoDB]
no-post-nav: true
---

## MySQL
### 索引
#### 目的
索引的目的在于提高查询效率，可以类比字典。
#### 原理
底层通过B+树实现
#### 类型及注意点
- 单列索引：只有一个列的索引，可通过 CREATE INDEX index_name ON table_name (column_name) 创建。注意：where子句中使用索引字段or来连接非索引字段将导致引擎放弃索引而进行全表扫描。
- 联合索引：多个列组合在一起的索引，可通过 CREATE INDEX index_name ON table_name (column1_name,column2_name,column3_name) 创建。注意：where子句联合索引字段不能用or连接；
用and连接时必须包含联合索引的第一个字段；否则引擎不会使用索引。
- 聚集索引：聚集索引确定表中数据的物理顺序，一个表只能包含一个聚集索引，但该索引可以包含多个列（联合索引）（不过mysql的innodb只支持主键聚集索引，不支持联合聚集索引）。
注意：1，如果一个主键被定义了，那么这个主键就是作为聚集索引；2，如果没有主键被定义，那么该表的第一个唯一非空索引被作为聚集索引；3，如果没有主键也没有合适的唯一索引，那么innodb内部会生成一个隐藏的主键作为聚集索引，这个隐藏的主键是一个6个字节的列，改列的值会随着数据的插入自增。
- 非聚集索引：一种索引，该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表可以包含多个非聚集索引。注意：innodb的非聚集索引的叶子节点上的data是主键，为什么存放的主键，而不是记录所在地址呢，理由相当简单，因为记录所在地址并不能保证一定不会变，但主键可以保证。
- 唯一索引：标识改索引的值具有唯一性，可以为单列索引或联合索引。可通过 ALTER TABLE table_name ADD UNIQUE INDEX index_name(column_name ...);

参考文档：[单列索引和联合索引](https://blog.csdn.net/Abysscarry/article/details/80792876)，[explain执行计划](https://juejin.im/post/5ce61072f265da1b5e72cb20)

#### 建索引的几大原则
1. 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。
2. =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。
3. 尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。
4. 索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。
5. 尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

### 常用优化方案
#### 相关配置优化
- 配置慢查询时间，开启慢查询监控，查看慢查询记录日志，通过explain查看执行计划。
- 连接数控制，通过 show variables like 'max_connections' 查看最大连接数，然后通过 show global status like ‘Max_used_connections’ 查看过去响应的最大连接数，连接数比较理想的设置为 Max_used_connections / max_connections * 100% ≈ 85%，当访问量过大时就需要考虑增加从服务器分散读压力。
- 添加合适的索引：索引要建在区分度高的字段上；索引也不是越多越好。

#### sql优化
- 不要使用 select * from table_name ，用具体的字段代替 *
- 尽量避免在where子句中使用 != < > 操作符、对字段进行null值判断、对字段进行表达式操作、使用or来连接条件、使用like进行最左侧模糊查询、使用in和not in，这些操作都可能导致引擎放弃使用索引而进行全表扫描。

具体内容参考[MySQL优化](https://segmentfault.com/a/1190000012155267)
## Redis
### 优点
- 高性能，提供十万级QPS
- 丰富的数据类型，有String、List、Set、Sorted Set、Hash五种基础的数据结构，同时还提供BitMap、HyperLogLog、GEO等高级数据结构
- 内置Redis Sentinel，提供高可用方案，实现主从故障自动转移
- 内置Redis Cluster，提供集群方案，实现基于槽的分片方案，从而支持更大的Redis规模

### 为什么Redis单线程模型也能效率这么高
- C语言实现
- 纯内存操作
- 基于非阻塞的IO多路复用机制
- 单线程，避免多线程的频繁上下文切换问题
- 丰富的数据结构和高效的算法实现

### 持久化方式
#### RDB(Redis DataBase)
通过配置redis在n秒内如果超过m个key被修改则执行一次持久化快照文件操作，持久化结束后，用这个临时快照文件替换上次持久化的文件。因为RDB是间隔一段时间进行持久化，当间隔期间redis发生故障将导致部分数据丢失，所以这种方式更适合用在数据要求不严谨的场景下使用。
#### AOF(Append Only File)
对每条写入命令作为日志，以append-only的模式写入一个日志文件中，和mysql的bin.log设计思想一致。可通过appendfsync配置项来设置文件同步策略，默认为everysec，即每秒进行append日志文件。如果遇物理服务器故障，可能导致最近一秒的aof记录丢失。相比RDB方式来说，可靠性更高，但是磁盘IO负载更大。

### 数据过期策略
- 惰性删除：当读/写一个已经过期的keey时，会直接删除掉这个过期的key
- 主动删除：由于惰性删除策略无法保证冷数据被及时删除，所以redis会定期主动淘汰一批已过期的key

### 数据淘汰策略
当前已用内存超过maxmemory限定时，触发数据淘汰策略，不同版本的默认策略不一样，主要包括：
- volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
- volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
- volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
- allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
- allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
- noeviction：禁止驱逐数据，当内存使用达到阈值的时候，所有引起申请内存的命令会报错

### redis常见应用场景
- 缓存：针对查多写少的热点数据进行缓存，提高查询效率。
- 会话缓存：解决分布式session问题。
- 时效性：例如短信验证码、token等具有时效性的数据。
- 计数器：需要原子递增保持计数。
- 消息队列：使用list，可以作为一个简单的消息队列使用。
- 社交列表：使用set存储用户的粉丝列表，同时支持求交集、并集、差集，例如统计两个人的共同好友。
- 排行榜：使用sorted set，根据score值进行排序。
- 分布式锁：通过setnx来实现分布式锁，相比于zookeeper的分布式锁实现性能更高，但可靠性略低。

### 常见问题及解决方案
#### 缓存穿透
指查询一个 __一定不存在__ 的数据，由于缓存不命中时被动写（缓存中不存在的数据，去DB中查询到该数据，然后写入到缓存中），每次查询都会去DB中查询。如果大流量查询此数据，严重的话可能会把DB搞挂。有如下解决方案：
1. 缓存空对象：当从DB查询数据为空，我们也要把这个空结果进行缓存，具体的值需要使用 __特殊的标识__，能和真正的缓存数据区分开。另外，还需要设置 __过短的有效期__，一般不超过5分钟。
2. 布隆过滤器：在查DB之前先查bl，bl里面放存在的key，如果bl里存在则往下查DB，否则直接返回不存在。由于bl设计思想导致 __存在的不一定存在，不存在的一定不存在__，所以也会导致误判，误判率和bl中存储的元素数量成正相关。

#### 缓存雪崩
指redis服务由于某些原因无法提供服务，所有请求全部打到DB中，导致DB负荷大增，最终挂掉，导致整个服务不可用的情况。有如下解决方案：
1. 缓存高可用：可以使用redis sentinel或redis cluster来搭建高可用的redis服务集群。
2. 限流：通过限制DB每秒请求数，避免DB被打挂的情况，保证服务可用。同时配合Sentinel、Hystrix实现服务的熔断降级，虽然会影响到部分用户的体验，总比所有用户都无法使用要好。
3. 本地缓存，即使redis挂了，也可以将DB查询到的结果缓存到本地，避免后续请求持续打到DB中。但是多引入一层缓存将带来很多额外的问题，故不推荐此方案。

#### 缓存击穿
指某个 __极度热点__ 数据在某个时间点过期时，恰好在这个时间点对这个key有大量的并发请求过来，大量请求瞬间击垮DB（注意和 _缓存穿透_ 区分）。有如下解决方案：
1. 使用互斥锁，请求发现缓存不存在后，在查询DB之前，获取分布式锁（查询DB更新缓存的钥匙）保证有且只有一个线程去查询DB，并将查询结果更新至缓存。
2. 手动过期：缓存上不设置过期时间，功能上将过期时间放在key对应的value里。首先获取缓存，通过value的过期时间判断是否过期。没过期的直接返回，过期了的获取分布式锁，获取锁失败的直接返回，成功的负责更新缓存。这样做可以无需用户等待，但是会有很小的时延性。

## MongoDb