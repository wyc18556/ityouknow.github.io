---
layout: post
title: 数据结构与算法之美-排序算法
category: note
tags: [algorithm]
keywords: algorithm
no-post-nav: true
---

## 如何分析一个排序算法

### 执行效率
- 最好情况、最坏情况、平均情况时间复杂度。
- 时间复杂度的系数、常数、低阶也要考虑进来。
- 比较次数和交换（或移动）次数。

### 内存消耗
算法的内存消耗随数据规模n的增长关系可以用空间复杂度来衡量。针对排序算法，还需引入一个新的概念：**原地排序**，特指空间复杂度为O(1)的排序算法。

### 稳定性
如果待排序的序列中存在值相等的元素，经过某一排序算法排序之后，相等元素之间的原有的前后顺序不变，这种算法就是**稳定排序算法**。通常在讲排序算法的时候都是使用整数来举例的，但是在实际的开发中，需要排序的往往是一组对象，我们需要按照对象的某一个属性key来排序，这个时候你所使用的排序算法是否具有稳定性就能体现出来了。  

例如，现在要求我们对一组订单按订单金额从大到小排序，订单金额相同的按下单时间从早到晚排序。最先想到的方法可能是：我们先按照金额进行排序，然后再遍历排序过的订单数据，对每个订单金额相同的小区间再按照下单时间排序。这种排序思路理解起来不难，但是实现起来会比较复杂。    

借助稳定排序算法，我们可以先按照下单时间从早到晚排序，然后对排序完成的订单数据再使用稳定排序算法按订单金额重新排序。注意，第二次排序时要使用稳定排序算法，那么两次排序之后的结果就是题目要求的结果了。

## 常见的排序算法
下面的篇幅会从时间复杂度、空间复杂度、稳定性三个方面对常见的排序算法进行分析，至于相关排序算法的代码实现请[点击这里](https://github.com/wyc18556/algorithms/tree/master/src/sort)查看。
### 冒泡排序
#### 时间复杂度
- 最差时间复杂度O(n^2)。
- 平均时间复杂度O(n)。
- 要排序的数据已经是有序的了，最好时间复杂度O(n)。
#### 空间复杂度
冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为O(1)，是一个 _原地排序算法_。
##### 稳定性分析
