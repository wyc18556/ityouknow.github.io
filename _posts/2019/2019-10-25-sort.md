<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

---
layout: post
title: 数据结构与算法之美-排序算法
category: note
tags: [algorithm]
keywords: algorithm
no-post-nav: true
---

## 如何分析一个排序算法

### 执行效率
- 最好情况、最坏情况、平均情况时间复杂度。
- 时间复杂度的系数、常数、低阶也要考虑进来。
- 比较次数和交换（或移动）次数。

### 内存消耗
算法的内存消耗随数据规模n的增长关系可以用空间复杂度来衡量。针对排序算法，还需引入一个新的概念：**原地排序算法**，特指空间复杂度为O(1)的排序算法。

### 稳定性
如果待排序的序列中存在值相等的元素，经过某一排序算法排序之后，相等元素之间的原有的前后顺序不变，这种算法就是**稳定排序算法**。通常在讲排序算法的时候都是使用整数来举例的，但是在实际的开发中，需要排序的往往是一组对象，我们需要按照对象的某一个属性key来排序，这个时候你所使用的排序算法是否具有稳定性就能体现出来了。  

例如，现在要求我们对一组订单按订单金额从大到小排序，订单金额相同的按下单时间从早到晚排序。最先想到的方法可能是：我们先按照金额进行排序，然后再遍历排序过的订单数据，对每个订单金额相同的小区间再按照下单时间排序。这种排序思路理解起来不难，但是实现起来会比较复杂。    

借助稳定排序算法，我们可以先按照下单时间从早到晚排序，然后对排序完成的订单数据再使用稳定排序算法按订单金额重新排序。注意，第二次排序时要使用稳定排序算法，那么两次排序之后的结果就是题目要求的结果了。

## 常见的排序算法
下面的篇幅会从时间复杂度、空间复杂度、稳定性三个方面对常见的排序算法进行分析，至于相关排序算法的代码实现请[点击这里](https://github.com/wyc18556/algorithms/tree/master/src/sort)查看。
### 冒泡排序
#### 时间复杂度
- 最差时间复杂度O\\(n^2\\))。
- 平均时间复杂度O(\\(n^2\\))。
- 要排序的数据已经是有序的了，最好时间复杂度O(n)。

#### 空间复杂度
冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为O(1)，是一个原地排序算法。

##### 稳定性分析
当相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。

### 插入排序
#### 时间复杂度
- 最差时间复杂度O(\\(n^2\\))。
- 平均时间复杂度O(\\(n^2\\))。
- 如果要排序的数据已经是有序的了，每次只需要比较一个数据就能确定插入的位置，最好时间复杂度O(n)。

#### 空间复杂度
排序过程只涉及到比较和交换操作，空间复杂度为O(1)，是一个原地排序算法。

#### 稳定性分析
对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，保证相等元素原有的前后顺序不变，所以插入排序是稳定的排序算法。

### 选择排序
#### 时间复杂度
- 最差时间复杂度O(\\(n^2\\))。
- 平均时间复杂度O(\\(n^2\\))。
- 最好时间复杂度O(\\(n^2\\))。

#### 空间复杂度
排序过程只涉及到比较和交换操作，空间复杂度为O(1)，是一个原地排序算法。

#### 稳定性分析
选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样就破坏了稳定性。

### 归并排序
#### 时间复杂度


#### 空间复杂度

#### 稳定性分析

### 快速排序
#### 时间复杂度

#### 空间复杂度

#### 稳定性分析

### 桶排序
#### 时间复杂度

#### 空间复杂度

#### 稳定性分析

### 计数排序
#### 时间复杂度

#### 空间复杂度

#### 稳定性分析

### 基数排序
#### 时间复杂度

#### 空间复杂度

#### 稳定性分析

## 思考题
> 冒泡排序和插入排序的时间复杂度都是O(\\(n^2\\))，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？
>> 对比一下冒泡排序和插入排序的代码实现你就会发现，冒泡排序的元素交换需要借助一个临时变量temp，需要三次赋值操作。而插入排序的数据移动只需一次赋值操作即可完成。
